<HTML>

<STYLE>

body {
	font-family: "Realbook", Arial, sans-serif ;
}

.tune {
}

.composer {
	font-size: 1.25em ;
	width: 50% ;
}

.style {
	font-size: 1.25em ;
	text-align: right ;
	width: 50% ;
}

.title {
	font-size: 1.75em ;
	text-align: center ;
}

.label {
	font-size: 1.25em ;
}

.description {
	font-size: 1.25em ;
}

.prebar {
    border-left: 3px solid black ;
    width: 1px ;
}

.prebar2 {
    border-left: 8px double black ;
    width: 1px ;
}

.postbar {
    border-right: 3px solid black ;
    width: 1px ;
}

.postbar2 {
    border-right: 8px double black ;
    width: 1px ;
}

.ending {
    border-top: 2px solid black ;
    border-left: 2px solid black ;
    width: 1px ;
}

.q {
   font-size: 0.75em ;
}

.chord {
	font-size: 3em ;
	// font-weight: bold ;
}

.smallchord {
	font-size: 2.5em ;
	// font-weight: bold ;
}

.comment {
}

th {
	text-aligh: left ;
}

.cols {
	width: 10em ;
}

@font-face {
	font-family: Realbook ;
	src: url(realbook-webfont.woff) ;
}

</STYLE>


<BODY>

<SCRIPT>
/* A tune is composed of:
	- title:
	- composer:
	- style:
	- key:
	- sections: A list of section that build up the tune.

Each section can contain:
	- label: Section label (A, B, I, ...)
	- description: Comment to be displayed at the top of the section, next to the label
	- repeat: number of times the section should be repeated
	- bars: A list of bars

Each bar can contain:
	- coda, segno?
	- repeat_last: repeat last bar (1, %) or last two bars (2, %%).
	- meter: Time signature for the bar (4/4). Carries on from the last bar if not specified.
	- beats: number of beats in the bar. Carries on from the last bar if not specified.
	- chords: A list of chords

Each chord can contain:
	- name:
	- beats: Number of beats for the chord. If not specified, remaining time is divided evenly between chords.

*/


var params = parse_query_string() ;
var name = params['t'] ;

var debug = params['debug'] ;
var beats_per_bar = 4 ;
var col = 0 ;

var tbl ;
var top_tr, mid_tr, bot_tr ;
var last_postbar, last_ending_col ;


var dir = "http://35.196.250.42/tunes/" ;
var xmlhttp = new XMLHttpRequest() ;
xmlhttp.onreadystatechange = function(){
    if (this.readyState == 4 && this.status == 200){
        var tune = JSON.parse(this.responseText) ;
        display(tune) ;
    }
} ;
xmlhttp.open("GET", dir + name + ".json", true) ;
xmlhttp.send() ;


function parse_query_string(){
    var params = {} ;

    if (location.search){
	    var queries = location.search.substring(1).split("&") ;
	    for (var i = 0, l = queries.length ; i < l; i++){
	        var temp = queries[i].split('=') ;
	        params[temp[0]] = temp[1] ;
	    }
	}

    return params ;
}


function display(tune) {
	header(document.body, tune) ;

	for (var i in tune.sections){
		var s = tune.sections[i] ;
		section(s) ;
	}
}


function header(parent, tune){
	tbl = document.createElement('table') ;
    parent.appendChild(tbl) ;
    if (debug){
		tbl.setAttribute("border", "1") ;
	}
	tbl.className = "tune" ;

	var tr = tbl.insertRow() ;
	var td = tr.insertCell() ;
	td.setAttribute("colspan", 6) ;
	td.className = "composer" ;
	td.innerHTML = tune.composer ;
	td = tr.insertCell() ;
	td.setAttribute("colspan", 6) ;
	td.className = "style" ;
	td.innerHTML = tune.style ;

	var tr = tbl.insertRow() ;
	var td = tr.insertCell() ;
	td.setAttribute("colspan", 12) ;
	td.className = "title" ;
	td.innerHTML = tune.title ;
}


/* Each section is a table that is 12 columns wide (4 prebars, 4 bars, 4 postbars)
*/
function section(section){
	var repeat = (section.repeat ? section.repeat : 0) ;
    var label = fix_label(section.label) ;
	var description = (section.description ? section.description : "") ;

	// We go through the bars of the section.
	if ((section.bars)&&(section.bars.length > 0)){
		for (var i = 0 ; i < section.bars.length ; i++){
			var first = (i == 0 ? true : false) ;
			var last = (i == (section.bars.length - 1) ? true : false) ;

            prebar((first ? label : ""), first, repeat) ;
        	bar(section.bars[i], (first ? description : "")) ;

			if ((last)&&(repeat)&&(section.endings)){
				// Force a plain bar line.
				postbar(0, 0) ;
			}
			else {
                postbar(last, repeat) ;
			}

 			col++ ;
            if (col == 4){
				col = 0 ;
			}
		}
	}

    if ((section.endings)&&(section.endings.length > 0)){
		for (var e = 0 ; e < section.endings.length ; e++){
			var ending = section.endings[e] ;
			if ((ending.bars)&&(ending.bars.length > 0)){
				for (var i = 0 ; i < ending.bars.length ; i++){
					var first = (i == 0 ? true : false) ;
					var last = (i == (ending.bars.length - 1) ? true : false) ;

					// For repeat section, we never use double bar lines or repeats
                    prebar("", false, false) ;
			        bar(ending.bars[i], (first ? "&nbsp;" + ending.no + "." : ""), first) ;

					if ((last)&&(ending.no == 1)){
						// Force a repeat bar line
						postbar(last, true) ;
						last_ending_col = col ;
					}
					else {
		                postbar(last, false) ;
					}

	                col++ ;
					if (col == 4){
						col = 0 ;
					}
				}
			}
		}
	}
}


function fix_label(label){
	label = (label ? label.substring(0, 1).toUpperCase() : "") ;
	// TODO: What to do with the rest on the string?
	switch (label) {
		case "A": return "&#x0391;" ;
		case "B": return "&#x0392;" ;
		case "C": return "&#x0393;" ;
		case "D": return "&#x0394;" ;
		case "E": return "&#x0395;" ;
		case "F": return "&#x0396;" ;
		default : return (label ? "(" + label + ")" : "") ;
	}
}


/* A bar is opened if it is the first bar of a section or of a line.
   Also, if it is the first bar of the section and it is a repeat section, we put the repeat sign.
*/
function prebar(label, first, repeat){
	if ((col == 0)||((first)&&(label))){
	    top_tr = tbl.insertRow() ;
	    mid_tr = tbl.insertRow() ;
	    bot_tr = tbl.insertRow() ;
	    if (col != 0){
	    	last_postbar.className = "postbar2" ;
		    col = 0 ;
		}
	}

	var td = top_tr.insertCell() ;
	td.className = "label" ;
	td.innerHTML = (label ? label : "&nbsp;") ;

    td = mid_tr.insertCell() ;
    if ((first)&&(col == 0)){
        td.className = "prebar2" ;
    }
    else if (col == 0){
		td.className = "prebar" ;
    }

    if ((first)&&(repeat)){
		td.innerHTML = "<span class='chord'>:</span>" ;
    }

 	td = bot_tr.insertCell() ; // empty cell
}


/* A bar is always closed with a single bar line, except when it is the last bar in the section
   where we need to use a double bar.

   Also, if it is the last bar of the section and it is a repeat section, we put the repeat sign.
*/
function postbar(last, repeat){
	var td = top_tr.insertCell() ; // empty cell

    td = mid_tr.insertCell() ;
    td.className = "postbar" ;
	last_postbar = td ;

	if (last){
		td.className = "postbar2" ;
		if (repeat){
			td.innerHTML = "<span class='chord'>:</span>" ;
		}
	}

 	td = bot_tr.insertCell() ; // empty cell
}


/* A bar is a table, that consists, for now, of two rows:
	- Chord names
	- Beat staff
*/
function bar(bar, description, ending = 0){
	if (bar.beats > 0){
		beats_per_bar = bar.beats ;
	}

	var td = top_tr.insertCell() ;
	if (ending){
		td.className = "ending" ;
	}
	if (description){
		td.innerHTML = "<span class='description'>" + description + "</span>" ;
	}

	td = mid_tr.insertCell() ;
	td.className = "cols" ;
	var tbl = document.createElement('table') ;
	td.appendChild(tbl) ;
	if (debug){
	    tbl.setAttribute("border", "1") ;
	}
    tbl.style.width = "100%" ;

    // Insert the guide row
    var tr = tbl.insertRow() ;
	for (var i = 0 ; i < beats_per_bar ; i++){
		td = tr.insertCell() ;
		td.height = "1px" ;
		td.style.width = "25%" ;
	}

    tr = tbl.insertRow() ;
	if (bar.repeat_last == 1){
		td = tr.insertCell() ;
		td.className = "chord" ;
		td.setAttribute('colspan', beats_per_bar) ;
		td.style.textAlign = 'center' ;
		td.innerHTML = "%" ;
	}
	else if (bar.repeat_last == 2){
		td = tr.insertCell() ;
		td.className = "chord" ;
		td.setAttribute('colspan', beats_per_bar) ;
		td.style.textAlign = 'right' ;
		td.innerHTML = "%" ;
	}
	else {
		if ((bar.chords)&&(bar.chords.length > 0)){
			for (var i in bar.chords){
				var c = bar.chords[i] ;
				var cols = (c.beats > 0 ? c.beats : beats_per_bar) ;
				td = tr.insertCell() ;
				if (cols > 1){
					td.setAttribute("colspan", cols) ;
					td.className = "chord" ;
				}
				else {
	            	td.className = "smallchord" ;
				}
				chord(td, c) ;
			}
		}
		else {
			// This can probably happen in other cases...
			td = tr.insertCell() ;
			td.className = "chord" ;
			td.setAttribute('colspan', beats_per_bar) ;
			td.style.textAlign = 'left' ;
			td.innerHTML = "%" ;
		}
	}

	td = bot_tr.insertCell() ;
	td.className = "comment" ;
	if ((bar.comments)&&(bar.comments.length > 0)){
		td.innerHTML = bar.comments.join(", ") ;
	}
}


function chord(parent, chord){
	var c = chord.name ;
	var matches = c.match(/^([_A-G])(b|#|)(.*)$/) ;
	if ((matches)&&(matches.length > 0)){
		var acc = matches[2] ;
		var rest = matches[3] ;
		acc = acc.replace("#", "&#x03B3;") ;
		acc = acc.replace("b", "&#x03B2;") ;

		// rest = rest.replace(/\/(.*)/, "<br/>/$1") ;

	    rest = rest.replace("#", "&#x03B3;") ;
		rest = rest.replace("b", "<sup>&#x03B2;</sup>") ;

		parent.innerHTML = matches[1] + acc + "<span class='q'><sup>" + rest + "</sup></span>" + "&nbsp;" ;
	}
	else {
		parent.innerHTML = c + "&nbsp;" ;
	}
}
</SCRIPT>




















